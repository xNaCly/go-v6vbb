// Package vbb provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version 2.1.0 DO NOT EDIT.
package vbb

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

// Defines values for GetJourneysParamsWalkingSpeed.
const (
	Fast   GetJourneysParamsWalkingSpeed = "fast"
	Normal GetJourneysParamsWalkingSpeed = "normal"
	Slow   GetJourneysParamsWalkingSpeed = "slow"
)

// Defines values for GetMapsTypeParamsType.
const (
	Brb         GetMapsTypeParamsType = "brb"
	Bvg         GetMapsTypeParamsType = "bvg"
	BvgNight    GetMapsTypeParamsType = "bvg-night"
	BvgRefugees GetMapsTypeParamsType = "bvg-refugees"
	BvgTram     GetMapsTypeParamsType = "bvg-tram"
	Cb          GetMapsTypeParamsType = "cb"
	CbNight     GetMapsTypeParamsType = "cb-night"
	Ff          GetMapsTypeParamsType = "ff"
	P           GetMapsTypeParamsType = "p"
	PNight      GetMapsTypeParamsType = "p-night"
	Vbb         GetMapsTypeParamsType = "vbb"
)

// GetJourneysParams defines parameters for GetJourneys.
type GetJourneysParams struct {
	// Departure Compute journeys departing at this date/time. Mutually exclusive with `arrival`. – Default: *now*
	Departure *time.Time `form:"departure,omitempty" json:"departure,omitempty"`

	// Arrival Compute journeys arriving at this date/time. Mutually exclusive with `departure`. – Default: *now*
	Arrival *time.Time `form:"arrival,omitempty" json:"arrival,omitempty"`

	// EarlierThan Compute journeys "before" an `ealierRef`.
	EarlierThan *string `form:"earlierThan,omitempty" json:"earlierThan,omitempty"`

	// LaterThan Compute journeys "after" an `laterRef`.
	LaterThan *string `form:"laterThan,omitempty" json:"laterThan,omitempty"`

	// Results Max. number of journeys.
	Results *int `form:"results,omitempty" json:"results,omitempty"`

	// Stopovers Fetch & parse stopovers on the way?
	Stopovers *bool `form:"stopovers,omitempty" json:"stopovers,omitempty"`

	// Transfers Maximum number of transfers. – Default: *let HAFAS decide*
	Transfers *int `form:"transfers,omitempty" json:"transfers,omitempty"`

	// TransferTime Minimum time in minutes for a single transfer.
	TransferTime *int `form:"transferTime,omitempty" json:"transferTime,omitempty"`

	// Accessibility `partial` or `complete`. – Default: *not accessible*
	Accessibility *string `form:"accessibility,omitempty" json:"accessibility,omitempty"`

	// Bike Compute only bike-friendly journeys?
	Bike *bool `form:"bike,omitempty" json:"bike,omitempty"`

	// StartWithWalking Consider walking to nearby stations at the beginning of a journey?
	StartWithWalking *bool `form:"startWithWalking,omitempty" json:"startWithWalking,omitempty"`

	// WalkingSpeed `slow`, `normal` or `fast`.
	WalkingSpeed *GetJourneysParamsWalkingSpeed `form:"walkingSpeed,omitempty" json:"walkingSpeed,omitempty"`

	// Tickets Return information about available tickets?
	Tickets *bool `form:"tickets,omitempty" json:"tickets,omitempty"`

	// Polylines Fetch & parse a shape for each journey leg?
	Polylines *bool `form:"polylines,omitempty" json:"polylines,omitempty"`

	// SubStops Parse & return sub-stops of stations?
	SubStops *bool `form:"subStops,omitempty" json:"subStops,omitempty"`

	// Entrances Parse & return entrances of stops/stations?
	Entrances *bool `form:"entrances,omitempty" json:"entrances,omitempty"`

	// Remarks Parse & return hints & warnings?
	Remarks *bool `form:"remarks,omitempty" json:"remarks,omitempty"`

	// ScheduledDays Parse & return dates each journey is valid on?
	ScheduledDays *bool `form:"scheduledDays,omitempty" json:"scheduledDays,omitempty"`

	// Language Language of the results.
	Language *string `form:"language,omitempty" json:"language,omitempty"`

	// Pretty Pretty-print JSON responses?
	Pretty *bool  `form:"pretty,omitempty" json:"pretty,omitempty"`
	From   string `form:"from" json:"from"`
	To     string `form:"to" json:"to"`
}

// GetJourneysParamsWalkingSpeed defines parameters for GetJourneys.
type GetJourneysParamsWalkingSpeed string

// GetJourneysRefParams defines parameters for GetJourneysRef.
type GetJourneysRefParams struct {
	// Stopovers Fetch & parse stopovers on the way?
	Stopovers *bool `form:"stopovers,omitempty" json:"stopovers,omitempty"`

	// Tickets Return information about available tickets?
	Tickets *bool `form:"tickets,omitempty" json:"tickets,omitempty"`

	// Polylines Fetch & parse a shape for each journey leg?
	Polylines *bool `form:"polylines,omitempty" json:"polylines,omitempty"`

	// SubStops Parse & return sub-stops of stations?
	SubStops *bool `form:"subStops,omitempty" json:"subStops,omitempty"`

	// Entrances Parse & return entrances of stops/stations?
	Entrances *bool `form:"entrances,omitempty" json:"entrances,omitempty"`

	// Remarks Parse & return hints & warnings?
	Remarks *bool `form:"remarks,omitempty" json:"remarks,omitempty"`

	// ScheduledDays Parse & return dates the journey is valid on?
	ScheduledDays *bool `form:"scheduledDays,omitempty" json:"scheduledDays,omitempty"`

	// Language Language of the results.
	Language *string `form:"language,omitempty" json:"language,omitempty"`

	// Pretty Pretty-print JSON responses?
	Pretty *bool `form:"pretty,omitempty" json:"pretty,omitempty"`
}

// GetLinesParams defines parameters for GetLines.
type GetLinesParams struct {
	// Id Filter by ID.
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// Name Filter by name.
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// Operator Filter by operator id. See [`agency.csv`](https://vbb-gtfs.jannisr.de/latest/agency.csv).
	Operator *string `form:"operator,omitempty" json:"operator,omitempty"`

	// Variants Return stops/stations along the line?
	Variants *bool `form:"variants,omitempty" json:"variants,omitempty"`

	// Mode Filter by mode of transport as in [*Friendly Public Transport Format* `1.2.1`](https://github.com/public-transport/friendly-public-transport-format/blob/1.2.1/spec/readme.md).
	Mode *string `form:"mode,omitempty" json:"mode,omitempty"`

	// Product Filter by [product](https://github.com/public-transport/hafas-client/blob/6/p/vbb/products.js).
	Product *string `form:"product,omitempty" json:"product,omitempty"`
}

// GetLocationsParams defines parameters for GetLocations.
type GetLocationsParams struct {
	// Query The term to search for.
	Query string `form:"query" json:"query"`

	// Fuzzy Find more than exact matches?
	Fuzzy *bool `form:"fuzzy,omitempty" json:"fuzzy,omitempty"`

	// Results How many stations shall be shown?
	Results *int `form:"results,omitempty" json:"results,omitempty"`

	// Stops Show stops/stations?
	Stops *bool `form:"stops,omitempty" json:"stops,omitempty"`

	// Addresses Show addresses?
	Addresses *bool `form:"addresses,omitempty" json:"addresses,omitempty"`

	// Poi Show points of interest?
	Poi *bool `form:"poi,omitempty" json:"poi,omitempty"`

	// LinesOfStops Parse & return lines of each stop/station?
	LinesOfStops *bool `form:"linesOfStops,omitempty" json:"linesOfStops,omitempty"`

	// Language Language of the results.
	Language *string `form:"language,omitempty" json:"language,omitempty"`

	// Pretty Pretty-print JSON responses?
	Pretty *bool `form:"pretty,omitempty" json:"pretty,omitempty"`
}

// GetLocationsNearbyParams defines parameters for GetLocationsNearby.
type GetLocationsNearbyParams struct {
	// Results maximum number of results
	Results *int `form:"results,omitempty" json:"results,omitempty"`

	// Distance maximum walking distance in meters – Default: –
	Distance *int `form:"distance,omitempty" json:"distance,omitempty"`

	// Stops Return stops/stations?
	Stops *bool `form:"stops,omitempty" json:"stops,omitempty"`

	// Poi Return points of interest?
	Poi *bool `form:"poi,omitempty" json:"poi,omitempty"`

	// LinesOfStops Parse & expose lines at each stop/station?
	LinesOfStops *bool `form:"linesOfStops,omitempty" json:"linesOfStops,omitempty"`

	// Language Language of the results.
	Language *string `form:"language,omitempty" json:"language,omitempty"`

	// Pretty Pretty-print JSON responses?
	Pretty *bool `form:"pretty,omitempty" json:"pretty,omitempty"`
}

// GetMapsTypeParamsType defines parameters for GetMapsType.
type GetMapsTypeParamsType string

// GetRadarParams defines parameters for GetRadar.
type GetRadarParams struct {
	// Results Max. number of vehicles.
	Results *int `form:"results,omitempty" json:"results,omitempty"`

	// Duration Compute frames for the next `n` seconds.
	Duration *int `form:"duration,omitempty" json:"duration,omitempty"`

	// Frames Number of frames to compute.
	Frames *int `form:"frames,omitempty" json:"frames,omitempty"`

	// Polylines Fetch & parse a geographic shape for the movement of each vehicle?
	Polylines *bool `form:"polylines,omitempty" json:"polylines,omitempty"`

	// Language Language of the results.
	Language *string `form:"language,omitempty" json:"language,omitempty"`

	// Pretty Pretty-print JSON responses?
	Pretty *bool `form:"pretty,omitempty" json:"pretty,omitempty"`
}

// GetStationsParams defines parameters for GetStations.
type GetStationsParams struct {
	// Query Find stations by name using [`vbb-stations-autocomplete@4.16.0`](https://github.com/derhuerst/vbb-stations-autocomplete/tree/4.16.0).
	Query *string `form:"query,omitempty" json:"query,omitempty"`

	// Limit *If `query` is used:* Return at most `n` stations.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Fuzzy *If `query` is used:* Find stations despite typos.
	Fuzzy *bool `form:"fuzzy,omitempty" json:"fuzzy,omitempty"`

	// Completion *If `query` is used:* Autocomplete stations.
	Completion *bool `form:"completion,omitempty" json:"completion,omitempty"`
}

// GetStopsReachableFromParams defines parameters for GetStopsReachableFrom.
type GetStopsReachableFromParams struct {
	// When Date & time to compute the reachability for. – Default: *now*
	When *time.Time `form:"when,omitempty" json:"when,omitempty"`

	// MaxTransfers Maximum number of transfers.
	MaxTransfers *int `form:"maxTransfers,omitempty" json:"maxTransfers,omitempty"`

	// MaxDuration Maximum travel duration, in minutes. – Default: *infinite*
	MaxDuration *int `form:"maxDuration,omitempty" json:"maxDuration,omitempty"`

	// Language Language of the results.
	Language *string `form:"language,omitempty" json:"language,omitempty"`

	// Pretty Pretty-print JSON responses?
	Pretty *bool `form:"pretty,omitempty" json:"pretty,omitempty"`
}

// GetStopsIdParams defines parameters for GetStopsId.
type GetStopsIdParams struct {
	// LinesOfStops Parse & expose lines at each stop/station?
	LinesOfStops *bool `form:"linesOfStops,omitempty" json:"linesOfStops,omitempty"`

	// Language Language of the results.
	Language *string `form:"language,omitempty" json:"language,omitempty"`

	// Pretty Pretty-print JSON responses?
	Pretty *bool `form:"pretty,omitempty" json:"pretty,omitempty"`
}

// GetStopsIdArrivalsParams defines parameters for GetStopsIdArrivals.
type GetStopsIdArrivalsParams struct {
	// When Date & time to get departures for. – Default: *now*
	When *time.Time `form:"when,omitempty" json:"when,omitempty"`

	// Direction Filter departures by direction.
	Direction *string `form:"direction,omitempty" json:"direction,omitempty"`

	// Duration Show departures for how many minutes?
	Duration *int `form:"duration,omitempty" json:"duration,omitempty"`

	// Results Max. number of departures. – Default: *whatever HAFAS wants*
	Results *int `form:"results,omitempty" json:"results,omitempty"`

	// LinesOfStops Parse & return lines of each stop/station?
	LinesOfStops *bool `form:"linesOfStops,omitempty" json:"linesOfStops,omitempty"`

	// Remarks Parse & return hints & warnings?
	Remarks *bool `form:"remarks,omitempty" json:"remarks,omitempty"`

	// Language Language of the results.
	Language *string `form:"language,omitempty" json:"language,omitempty"`

	// Pretty Pretty-print JSON responses?
	Pretty *bool `form:"pretty,omitempty" json:"pretty,omitempty"`
}

// GetStopsIdDeparturesParams defines parameters for GetStopsIdDepartures.
type GetStopsIdDeparturesParams struct {
	// When Date & time to get departures for. – Default: *now*
	When *time.Time `form:"when,omitempty" json:"when,omitempty"`

	// Direction Filter departures by direction.
	Direction *string `form:"direction,omitempty" json:"direction,omitempty"`

	// Duration Show departures for how many minutes?
	Duration *int `form:"duration,omitempty" json:"duration,omitempty"`

	// Results Max. number of departures. – Default: *whatever HAFAS wants
	Results *int `form:"results,omitempty" json:"results,omitempty"`

	// LinesOfStops Parse & return lines of each stop/station?
	LinesOfStops *bool `form:"linesOfStops,omitempty" json:"linesOfStops,omitempty"`

	// Remarks Parse & return hints & warnings?
	Remarks *bool `form:"remarks,omitempty" json:"remarks,omitempty"`

	// Language Language of the results.
	Language *string `form:"language,omitempty" json:"language,omitempty"`

	// Pretty Pretty-print JSON responses?
	Pretty *bool `form:"pretty,omitempty" json:"pretty,omitempty"`
}

// GetTripsParams defines parameters for GetTrips.
type GetTripsParams struct {
	// Query line name or Fahrtnummer
	Query *string `form:"query,omitempty" json:"query,omitempty"`

	// When Date & time to get trips for. – Default: *now*
	When *time.Time `form:"when,omitempty" json:"when,omitempty"`

	// FromWhen Together with untilWhen, forms a time frame to get trips for. Mutually exclusive with `when`. – Default: *now*
	FromWhen *time.Time `form:"fromWhen,omitempty" json:"fromWhen,omitempty"`

	// UntilWhen Together with fromWhen, forms a time frame to get trips for. Mutually exclusive with `when`. – Default: *now*
	UntilWhen *time.Time `form:"untilWhen,omitempty" json:"untilWhen,omitempty"`

	// OnlyCurrentlyRunning Only return trips that run within the specified time frame.
	OnlyCurrentlyRunning *bool `form:"onlyCurrentlyRunning,omitempty" json:"onlyCurrentlyRunning,omitempty"`

	// CurrentlyStoppingAt Only return trips that stop at the specified stop within the specified time frame.
	CurrentlyStoppingAt *string `form:"currentlyStoppingAt,omitempty" json:"currentlyStoppingAt,omitempty"`

	// LineName Only return trips with the specified line name.
	LineName *string `form:"lineName,omitempty" json:"lineName,omitempty"`

	// OperatorNames Only return trips operated by operators specified by their names, separated by commas.
	OperatorNames *string `form:"operatorNames,omitempty" json:"operatorNames,omitempty"`

	// Stopovers Fetch & parse stopovers of each trip?
	Stopovers *bool `form:"stopovers,omitempty" json:"stopovers,omitempty"`

	// Remarks Parse & return hints & warnings?
	Remarks *bool `form:"remarks,omitempty" json:"remarks,omitempty"`

	// SubStops Parse & return sub-stops of stations?
	SubStops *bool `form:"subStops,omitempty" json:"subStops,omitempty"`

	// Entrances Parse & return entrances of stops/stations?
	Entrances *bool `form:"entrances,omitempty" json:"entrances,omitempty"`

	// Language Language of the results.
	Language *string `form:"language,omitempty" json:"language,omitempty"`

	// Pretty Pretty-print JSON responses?
	Pretty *bool `form:"pretty,omitempty" json:"pretty,omitempty"`
}

// GetTripsIdParams defines parameters for GetTripsId.
type GetTripsIdParams struct {
	// Stopovers Fetch & parse stopovers on the way?
	Stopovers *bool `form:"stopovers,omitempty" json:"stopovers,omitempty"`

	// Remarks Parse & return hints & warnings?
	Remarks *bool `form:"remarks,omitempty" json:"remarks,omitempty"`

	// Polyline Fetch & parse the geographic shape of the trip?
	Polyline *bool `form:"polyline,omitempty" json:"polyline,omitempty"`

	// Language Language of the results.
	Language *string `form:"language,omitempty" json:"language,omitempty"`

	// Pretty Pretty-print JSON responses?
	Pretty *bool `form:"pretty,omitempty" json:"pretty,omitempty"`
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetJourneys request
	GetJourneys(ctx context.Context, params *GetJourneysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetJourneysRef request
	GetJourneysRef(ctx context.Context, ref string, params *GetJourneysRefParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLines request
	GetLines(ctx context.Context, params *GetLinesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLinesId request
	GetLinesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLocations request
	GetLocations(ctx context.Context, params *GetLocationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLocationsNearby request
	GetLocationsNearby(ctx context.Context, params *GetLocationsNearbyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMapsType request
	GetMapsType(ctx context.Context, pType GetMapsTypeParamsType, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRadar request
	GetRadar(ctx context.Context, params *GetRadarParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetShapesId request
	GetShapesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStations request
	GetStations(ctx context.Context, params *GetStationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStationsId request
	GetStationsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStopsReachableFrom request
	GetStopsReachableFrom(ctx context.Context, params *GetStopsReachableFromParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStopsId request
	GetStopsId(ctx context.Context, id string, params *GetStopsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStopsIdArrivals request
	GetStopsIdArrivals(ctx context.Context, id string, params *GetStopsIdArrivalsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStopsIdDepartures request
	GetStopsIdDepartures(ctx context.Context, id string, params *GetStopsIdDeparturesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTrips request
	GetTrips(ctx context.Context, params *GetTripsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTripsId request
	GetTripsId(ctx context.Context, id string, params *GetTripsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetJourneys(ctx context.Context, params *GetJourneysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJourneysRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetJourneysRef(ctx context.Context, ref string, params *GetJourneysRefParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJourneysRefRequest(c.Server, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLines(ctx context.Context, params *GetLinesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLinesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLinesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLinesIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLocations(ctx context.Context, params *GetLocationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLocationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLocationsNearby(ctx context.Context, params *GetLocationsNearbyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLocationsNearbyRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMapsType(ctx context.Context, pType GetMapsTypeParamsType, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMapsTypeRequest(c.Server, pType)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRadar(ctx context.Context, params *GetRadarParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRadarRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetShapesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetShapesIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStations(ctx context.Context, params *GetStationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStationsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStationsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStopsReachableFrom(ctx context.Context, params *GetStopsReachableFromParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStopsReachableFromRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStopsId(ctx context.Context, id string, params *GetStopsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStopsIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStopsIdArrivals(ctx context.Context, id string, params *GetStopsIdArrivalsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStopsIdArrivalsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStopsIdDepartures(ctx context.Context, id string, params *GetStopsIdDeparturesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStopsIdDeparturesRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTrips(ctx context.Context, params *GetTripsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTripsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTripsId(ctx context.Context, id string, params *GetTripsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTripsIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetJourneysRequest generates requests for GetJourneys
func NewGetJourneysRequest(server string, params *GetJourneysParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/journeys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Departure != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "departure", runtime.ParamLocationQuery, *params.Departure); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Arrival != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "arrival", runtime.ParamLocationQuery, *params.Arrival); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EarlierThan != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "earlierThan", runtime.ParamLocationQuery, *params.EarlierThan); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LaterThan != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "laterThan", runtime.ParamLocationQuery, *params.LaterThan); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Results != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "results", runtime.ParamLocationQuery, *params.Results); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Stopovers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stopovers", runtime.ParamLocationQuery, *params.Stopovers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Transfers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transfers", runtime.ParamLocationQuery, *params.Transfers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TransferTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transferTime", runtime.ParamLocationQuery, *params.TransferTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Accessibility != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accessibility", runtime.ParamLocationQuery, *params.Accessibility); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Bike != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bike", runtime.ParamLocationQuery, *params.Bike); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartWithWalking != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startWithWalking", runtime.ParamLocationQuery, *params.StartWithWalking); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WalkingSpeed != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "walkingSpeed", runtime.ParamLocationQuery, *params.WalkingSpeed); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tickets != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tickets", runtime.ParamLocationQuery, *params.Tickets); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Polylines != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "polylines", runtime.ParamLocationQuery, *params.Polylines); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubStops != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subStops", runtime.ParamLocationQuery, *params.SubStops); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Entrances != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "entrances", runtime.ParamLocationQuery, *params.Entrances); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Remarks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "remarks", runtime.ParamLocationQuery, *params.Remarks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScheduledDays != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scheduledDays", runtime.ParamLocationQuery, *params.ScheduledDays); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Pretty != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, params.From); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, params.To); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetJourneysRefRequest generates requests for GetJourneysRef
func NewGetJourneysRefRequest(server string, ref string, params *GetJourneysRefParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/journeys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Stopovers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stopovers", runtime.ParamLocationQuery, *params.Stopovers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tickets != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tickets", runtime.ParamLocationQuery, *params.Tickets); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Polylines != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "polylines", runtime.ParamLocationQuery, *params.Polylines); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubStops != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subStops", runtime.ParamLocationQuery, *params.SubStops); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Entrances != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "entrances", runtime.ParamLocationQuery, *params.Entrances); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Remarks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "remarks", runtime.ParamLocationQuery, *params.Remarks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScheduledDays != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scheduledDays", runtime.ParamLocationQuery, *params.ScheduledDays); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Pretty != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLinesRequest generates requests for GetLines
func NewGetLinesRequest(server string, params *GetLinesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lines")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Operator != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "operator", runtime.ParamLocationQuery, *params.Operator); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Variants != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "variants", runtime.ParamLocationQuery, *params.Variants); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Product != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "product", runtime.ParamLocationQuery, *params.Product); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLinesIdRequest generates requests for GetLinesId
func NewGetLinesIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lines/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLocationsRequest generates requests for GetLocations
func NewGetLocationsRequest(server string, params *GetLocationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/locations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, params.Query); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Fuzzy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fuzzy", runtime.ParamLocationQuery, *params.Fuzzy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Results != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "results", runtime.ParamLocationQuery, *params.Results); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Stops != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stops", runtime.ParamLocationQuery, *params.Stops); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Addresses != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "addresses", runtime.ParamLocationQuery, *params.Addresses); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Poi != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "poi", runtime.ParamLocationQuery, *params.Poi); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinesOfStops != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linesOfStops", runtime.ParamLocationQuery, *params.LinesOfStops); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Pretty != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLocationsNearbyRequest generates requests for GetLocationsNearby
func NewGetLocationsNearbyRequest(server string, params *GetLocationsNearbyParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/locations/nearby")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Results != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "results", runtime.ParamLocationQuery, *params.Results); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Distance != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "distance", runtime.ParamLocationQuery, *params.Distance); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Stops != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stops", runtime.ParamLocationQuery, *params.Stops); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Poi != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "poi", runtime.ParamLocationQuery, *params.Poi); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinesOfStops != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linesOfStops", runtime.ParamLocationQuery, *params.LinesOfStops); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Pretty != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMapsTypeRequest generates requests for GetMapsType
func NewGetMapsTypeRequest(server string, pType GetMapsTypeParamsType) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "type", runtime.ParamLocationPath, pType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/maps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRadarRequest generates requests for GetRadar
func NewGetRadarRequest(server string, params *GetRadarParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/radar")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Results != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "results", runtime.ParamLocationQuery, *params.Results); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Duration != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "duration", runtime.ParamLocationQuery, *params.Duration); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Frames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "frames", runtime.ParamLocationQuery, *params.Frames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Polylines != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "polylines", runtime.ParamLocationQuery, *params.Polylines); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Pretty != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetShapesIdRequest generates requests for GetShapesId
func NewGetShapesIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/shapes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStationsRequest generates requests for GetStations
func NewGetStationsRequest(server string, params *GetStationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Query != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, *params.Query); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fuzzy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fuzzy", runtime.ParamLocationQuery, *params.Fuzzy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Completion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "completion", runtime.ParamLocationQuery, *params.Completion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStationsIdRequest generates requests for GetStationsId
func NewGetStationsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStopsReachableFromRequest generates requests for GetStopsReachableFrom
func NewGetStopsReachableFromRequest(server string, params *GetStopsReachableFromParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stops/reachable-from")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.When != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "when", runtime.ParamLocationQuery, *params.When); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxTransfers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxTransfers", runtime.ParamLocationQuery, *params.MaxTransfers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxDuration != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxDuration", runtime.ParamLocationQuery, *params.MaxDuration); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Pretty != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStopsIdRequest generates requests for GetStopsId
func NewGetStopsIdRequest(server string, id string, params *GetStopsIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stops/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LinesOfStops != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linesOfStops", runtime.ParamLocationQuery, *params.LinesOfStops); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Pretty != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStopsIdArrivalsRequest generates requests for GetStopsIdArrivals
func NewGetStopsIdArrivalsRequest(server string, id string, params *GetStopsIdArrivalsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stops/%s/arrivals", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.When != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "when", runtime.ParamLocationQuery, *params.When); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Direction != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Duration != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "duration", runtime.ParamLocationQuery, *params.Duration); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Results != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "results", runtime.ParamLocationQuery, *params.Results); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinesOfStops != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linesOfStops", runtime.ParamLocationQuery, *params.LinesOfStops); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Remarks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "remarks", runtime.ParamLocationQuery, *params.Remarks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Pretty != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStopsIdDeparturesRequest generates requests for GetStopsIdDepartures
func NewGetStopsIdDeparturesRequest(server string, id string, params *GetStopsIdDeparturesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stops/%s/departures", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.When != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "when", runtime.ParamLocationQuery, *params.When); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Direction != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Duration != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "duration", runtime.ParamLocationQuery, *params.Duration); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Results != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "results", runtime.ParamLocationQuery, *params.Results); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinesOfStops != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linesOfStops", runtime.ParamLocationQuery, *params.LinesOfStops); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Remarks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "remarks", runtime.ParamLocationQuery, *params.Remarks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Pretty != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTripsRequest generates requests for GetTrips
func NewGetTripsRequest(server string, params *GetTripsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/trips")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Query != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, *params.Query); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.When != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "when", runtime.ParamLocationQuery, *params.When); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FromWhen != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromWhen", runtime.ParamLocationQuery, *params.FromWhen); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UntilWhen != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "untilWhen", runtime.ParamLocationQuery, *params.UntilWhen); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyCurrentlyRunning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "onlyCurrentlyRunning", runtime.ParamLocationQuery, *params.OnlyCurrentlyRunning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CurrentlyStoppingAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "currentlyStoppingAt", runtime.ParamLocationQuery, *params.CurrentlyStoppingAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LineName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lineName", runtime.ParamLocationQuery, *params.LineName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OperatorNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "operatorNames", runtime.ParamLocationQuery, *params.OperatorNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Stopovers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stopovers", runtime.ParamLocationQuery, *params.Stopovers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Remarks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "remarks", runtime.ParamLocationQuery, *params.Remarks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubStops != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subStops", runtime.ParamLocationQuery, *params.SubStops); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Entrances != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "entrances", runtime.ParamLocationQuery, *params.Entrances); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Pretty != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTripsIdRequest generates requests for GetTripsId
func NewGetTripsIdRequest(server string, id string, params *GetTripsIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/trips/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Stopovers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stopovers", runtime.ParamLocationQuery, *params.Stopovers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Remarks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "remarks", runtime.ParamLocationQuery, *params.Remarks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Polyline != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "polyline", runtime.ParamLocationQuery, *params.Polyline); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Pretty != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetJourneysWithResponse request
	GetJourneysWithResponse(ctx context.Context, params *GetJourneysParams, reqEditors ...RequestEditorFn) (*GetJourneysResponse, error)

	// GetJourneysRefWithResponse request
	GetJourneysRefWithResponse(ctx context.Context, ref string, params *GetJourneysRefParams, reqEditors ...RequestEditorFn) (*GetJourneysRefResponse, error)

	// GetLinesWithResponse request
	GetLinesWithResponse(ctx context.Context, params *GetLinesParams, reqEditors ...RequestEditorFn) (*GetLinesResponse, error)

	// GetLinesIdWithResponse request
	GetLinesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetLinesIdResponse, error)

	// GetLocationsWithResponse request
	GetLocationsWithResponse(ctx context.Context, params *GetLocationsParams, reqEditors ...RequestEditorFn) (*GetLocationsResponse, error)

	// GetLocationsNearbyWithResponse request
	GetLocationsNearbyWithResponse(ctx context.Context, params *GetLocationsNearbyParams, reqEditors ...RequestEditorFn) (*GetLocationsNearbyResponse, error)

	// GetMapsTypeWithResponse request
	GetMapsTypeWithResponse(ctx context.Context, pType GetMapsTypeParamsType, reqEditors ...RequestEditorFn) (*GetMapsTypeResponse, error)

	// GetRadarWithResponse request
	GetRadarWithResponse(ctx context.Context, params *GetRadarParams, reqEditors ...RequestEditorFn) (*GetRadarResponse, error)

	// GetShapesIdWithResponse request
	GetShapesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetShapesIdResponse, error)

	// GetStationsWithResponse request
	GetStationsWithResponse(ctx context.Context, params *GetStationsParams, reqEditors ...RequestEditorFn) (*GetStationsResponse, error)

	// GetStationsIdWithResponse request
	GetStationsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetStationsIdResponse, error)

	// GetStopsReachableFromWithResponse request
	GetStopsReachableFromWithResponse(ctx context.Context, params *GetStopsReachableFromParams, reqEditors ...RequestEditorFn) (*GetStopsReachableFromResponse, error)

	// GetStopsIdWithResponse request
	GetStopsIdWithResponse(ctx context.Context, id string, params *GetStopsIdParams, reqEditors ...RequestEditorFn) (*GetStopsIdResponse, error)

	// GetStopsIdArrivalsWithResponse request
	GetStopsIdArrivalsWithResponse(ctx context.Context, id string, params *GetStopsIdArrivalsParams, reqEditors ...RequestEditorFn) (*GetStopsIdArrivalsResponse, error)

	// GetStopsIdDeparturesWithResponse request
	GetStopsIdDeparturesWithResponse(ctx context.Context, id string, params *GetStopsIdDeparturesParams, reqEditors ...RequestEditorFn) (*GetStopsIdDeparturesResponse, error)

	// GetTripsWithResponse request
	GetTripsWithResponse(ctx context.Context, params *GetTripsParams, reqEditors ...RequestEditorFn) (*GetTripsResponse, error)

	// GetTripsIdWithResponse request
	GetTripsIdWithResponse(ctx context.Context, id string, params *GetTripsIdParams, reqEditors ...RequestEditorFn) (*GetTripsIdResponse, error)
}

type GetJourneysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *struct {
		EarlierRef            *string                  `json:"earlierRef,omitempty"`
		Journeys              []map[string]interface{} `json:"journeys"`
		LaterRef              *string                  `json:"laterRef,omitempty"`
		RealtimeDataUpdatedAt *int                     `json:"realtimeDataUpdatedAt,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetJourneysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJourneysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetJourneysRefResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *struct {
		Journey               map[string]interface{} `json:"journey"`
		RealtimeDataUpdatedAt *int                   `json:"realtimeDataUpdatedAt,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetJourneysRefResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJourneysRefResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLinesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *[]map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r GetLinesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLinesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLinesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r GetLinesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLinesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLocationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *[]map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r GetLocationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLocationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLocationsNearbyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *[]map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r GetLocationsNearbyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLocationsNearbyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMapsTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetMapsTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMapsTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRadarResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *struct {
		Movements             []map[string]interface{} `json:"movements"`
		RealtimeDataUpdatedAt *int                     `json:"realtimeDataUpdatedAt,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetRadarResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRadarResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetShapesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r GetShapesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetShapesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r GetStationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStationsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r GetStationsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStationsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStopsReachableFromResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *struct {
		Reachable             []map[string]interface{} `json:"reachable"`
		RealtimeDataUpdatedAt *int                     `json:"realtimeDataUpdatedAt,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetStopsReachableFromResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStopsReachableFromResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStopsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r GetStopsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStopsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStopsIdArrivalsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *struct {
		Arrivals              []map[string]interface{} `json:"arrivals"`
		RealtimeDataUpdatedAt *int                     `json:"realtimeDataUpdatedAt,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetStopsIdArrivalsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStopsIdArrivalsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStopsIdDeparturesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *struct {
		Departures            []map[string]interface{} `json:"departures"`
		RealtimeDataUpdatedAt *int                     `json:"realtimeDataUpdatedAt,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetStopsIdDeparturesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStopsIdDeparturesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTripsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *struct {
		RealtimeDataUpdatedAt *int                     `json:"realtimeDataUpdatedAt,omitempty"`
		Trips                 []map[string]interface{} `json:"trips"`
	}
}

// Status returns HTTPResponse.Status
func (r GetTripsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTripsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTripsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *struct {
		RealtimeDataUpdatedAt *int                   `json:"realtimeDataUpdatedAt,omitempty"`
		Trip                  map[string]interface{} `json:"trip"`
	}
}

// Status returns HTTPResponse.Status
func (r GetTripsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTripsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetJourneysWithResponse request returning *GetJourneysResponse
func (c *ClientWithResponses) GetJourneysWithResponse(ctx context.Context, params *GetJourneysParams, reqEditors ...RequestEditorFn) (*GetJourneysResponse, error) {
	rsp, err := c.GetJourneys(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJourneysResponse(rsp)
}

// GetJourneysRefWithResponse request returning *GetJourneysRefResponse
func (c *ClientWithResponses) GetJourneysRefWithResponse(ctx context.Context, ref string, params *GetJourneysRefParams, reqEditors ...RequestEditorFn) (*GetJourneysRefResponse, error) {
	rsp, err := c.GetJourneysRef(ctx, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJourneysRefResponse(rsp)
}

// GetLinesWithResponse request returning *GetLinesResponse
func (c *ClientWithResponses) GetLinesWithResponse(ctx context.Context, params *GetLinesParams, reqEditors ...RequestEditorFn) (*GetLinesResponse, error) {
	rsp, err := c.GetLines(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLinesResponse(rsp)
}

// GetLinesIdWithResponse request returning *GetLinesIdResponse
func (c *ClientWithResponses) GetLinesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetLinesIdResponse, error) {
	rsp, err := c.GetLinesId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLinesIdResponse(rsp)
}

// GetLocationsWithResponse request returning *GetLocationsResponse
func (c *ClientWithResponses) GetLocationsWithResponse(ctx context.Context, params *GetLocationsParams, reqEditors ...RequestEditorFn) (*GetLocationsResponse, error) {
	rsp, err := c.GetLocations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLocationsResponse(rsp)
}

// GetLocationsNearbyWithResponse request returning *GetLocationsNearbyResponse
func (c *ClientWithResponses) GetLocationsNearbyWithResponse(ctx context.Context, params *GetLocationsNearbyParams, reqEditors ...RequestEditorFn) (*GetLocationsNearbyResponse, error) {
	rsp, err := c.GetLocationsNearby(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLocationsNearbyResponse(rsp)
}

// GetMapsTypeWithResponse request returning *GetMapsTypeResponse
func (c *ClientWithResponses) GetMapsTypeWithResponse(ctx context.Context, pType GetMapsTypeParamsType, reqEditors ...RequestEditorFn) (*GetMapsTypeResponse, error) {
	rsp, err := c.GetMapsType(ctx, pType, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMapsTypeResponse(rsp)
}

// GetRadarWithResponse request returning *GetRadarResponse
func (c *ClientWithResponses) GetRadarWithResponse(ctx context.Context, params *GetRadarParams, reqEditors ...RequestEditorFn) (*GetRadarResponse, error) {
	rsp, err := c.GetRadar(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRadarResponse(rsp)
}

// GetShapesIdWithResponse request returning *GetShapesIdResponse
func (c *ClientWithResponses) GetShapesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetShapesIdResponse, error) {
	rsp, err := c.GetShapesId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetShapesIdResponse(rsp)
}

// GetStationsWithResponse request returning *GetStationsResponse
func (c *ClientWithResponses) GetStationsWithResponse(ctx context.Context, params *GetStationsParams, reqEditors ...RequestEditorFn) (*GetStationsResponse, error) {
	rsp, err := c.GetStations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStationsResponse(rsp)
}

// GetStationsIdWithResponse request returning *GetStationsIdResponse
func (c *ClientWithResponses) GetStationsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetStationsIdResponse, error) {
	rsp, err := c.GetStationsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStationsIdResponse(rsp)
}

// GetStopsReachableFromWithResponse request returning *GetStopsReachableFromResponse
func (c *ClientWithResponses) GetStopsReachableFromWithResponse(ctx context.Context, params *GetStopsReachableFromParams, reqEditors ...RequestEditorFn) (*GetStopsReachableFromResponse, error) {
	rsp, err := c.GetStopsReachableFrom(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStopsReachableFromResponse(rsp)
}

// GetStopsIdWithResponse request returning *GetStopsIdResponse
func (c *ClientWithResponses) GetStopsIdWithResponse(ctx context.Context, id string, params *GetStopsIdParams, reqEditors ...RequestEditorFn) (*GetStopsIdResponse, error) {
	rsp, err := c.GetStopsId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStopsIdResponse(rsp)
}

// GetStopsIdArrivalsWithResponse request returning *GetStopsIdArrivalsResponse
func (c *ClientWithResponses) GetStopsIdArrivalsWithResponse(ctx context.Context, id string, params *GetStopsIdArrivalsParams, reqEditors ...RequestEditorFn) (*GetStopsIdArrivalsResponse, error) {
	rsp, err := c.GetStopsIdArrivals(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStopsIdArrivalsResponse(rsp)
}

// GetStopsIdDeparturesWithResponse request returning *GetStopsIdDeparturesResponse
func (c *ClientWithResponses) GetStopsIdDeparturesWithResponse(ctx context.Context, id string, params *GetStopsIdDeparturesParams, reqEditors ...RequestEditorFn) (*GetStopsIdDeparturesResponse, error) {
	rsp, err := c.GetStopsIdDepartures(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStopsIdDeparturesResponse(rsp)
}

// GetTripsWithResponse request returning *GetTripsResponse
func (c *ClientWithResponses) GetTripsWithResponse(ctx context.Context, params *GetTripsParams, reqEditors ...RequestEditorFn) (*GetTripsResponse, error) {
	rsp, err := c.GetTrips(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTripsResponse(rsp)
}

// GetTripsIdWithResponse request returning *GetTripsIdResponse
func (c *ClientWithResponses) GetTripsIdWithResponse(ctx context.Context, id string, params *GetTripsIdParams, reqEditors ...RequestEditorFn) (*GetTripsIdResponse, error) {
	rsp, err := c.GetTripsId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTripsIdResponse(rsp)
}

// ParseGetJourneysResponse parses an HTTP response from a GetJourneysWithResponse call
func ParseGetJourneysResponse(rsp *http.Response) (*GetJourneysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJourneysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest struct {
			EarlierRef            *string                  `json:"earlierRef,omitempty"`
			Journeys              []map[string]interface{} `json:"journeys"`
			LaterRef              *string                  `json:"laterRef,omitempty"`
			RealtimeDataUpdatedAt *int                     `json:"realtimeDataUpdatedAt,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	}

	return response, nil
}

// ParseGetJourneysRefResponse parses an HTTP response from a GetJourneysRefWithResponse call
func ParseGetJourneysRefResponse(rsp *http.Response) (*GetJourneysRefResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJourneysRefResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest struct {
			Journey               map[string]interface{} `json:"journey"`
			RealtimeDataUpdatedAt *int                   `json:"realtimeDataUpdatedAt,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	}

	return response, nil
}

// ParseGetLinesResponse parses an HTTP response from a GetLinesWithResponse call
func ParseGetLinesResponse(rsp *http.Response) (*GetLinesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLinesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest []map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	}

	return response, nil
}

// ParseGetLinesIdResponse parses an HTTP response from a GetLinesIdWithResponse call
func ParseGetLinesIdResponse(rsp *http.Response) (*GetLinesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLinesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	}

	return response, nil
}

// ParseGetLocationsResponse parses an HTTP response from a GetLocationsWithResponse call
func ParseGetLocationsResponse(rsp *http.Response) (*GetLocationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLocationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest []map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	}

	return response, nil
}

// ParseGetLocationsNearbyResponse parses an HTTP response from a GetLocationsNearbyWithResponse call
func ParseGetLocationsNearbyResponse(rsp *http.Response) (*GetLocationsNearbyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLocationsNearbyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest []map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	}

	return response, nil
}

// ParseGetMapsTypeResponse parses an HTTP response from a GetMapsTypeWithResponse call
func ParseGetMapsTypeResponse(rsp *http.Response) (*GetMapsTypeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMapsTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetRadarResponse parses an HTTP response from a GetRadarWithResponse call
func ParseGetRadarResponse(rsp *http.Response) (*GetRadarResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRadarResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest struct {
			Movements             []map[string]interface{} `json:"movements"`
			RealtimeDataUpdatedAt *int                     `json:"realtimeDataUpdatedAt,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	}

	return response, nil
}

// ParseGetShapesIdResponse parses an HTTP response from a GetShapesIdWithResponse call
func ParseGetShapesIdResponse(rsp *http.Response) (*GetShapesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetShapesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	}

	return response, nil
}

// ParseGetStationsResponse parses an HTTP response from a GetStationsWithResponse call
func ParseGetStationsResponse(rsp *http.Response) (*GetStationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	}

	return response, nil
}

// ParseGetStationsIdResponse parses an HTTP response from a GetStationsIdWithResponse call
func ParseGetStationsIdResponse(rsp *http.Response) (*GetStationsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStationsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	}

	return response, nil
}

// ParseGetStopsReachableFromResponse parses an HTTP response from a GetStopsReachableFromWithResponse call
func ParseGetStopsReachableFromResponse(rsp *http.Response) (*GetStopsReachableFromResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStopsReachableFromResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest struct {
			Reachable             []map[string]interface{} `json:"reachable"`
			RealtimeDataUpdatedAt *int                     `json:"realtimeDataUpdatedAt,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	}

	return response, nil
}

// ParseGetStopsIdResponse parses an HTTP response from a GetStopsIdWithResponse call
func ParseGetStopsIdResponse(rsp *http.Response) (*GetStopsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStopsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	}

	return response, nil
}

// ParseGetStopsIdArrivalsResponse parses an HTTP response from a GetStopsIdArrivalsWithResponse call
func ParseGetStopsIdArrivalsResponse(rsp *http.Response) (*GetStopsIdArrivalsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStopsIdArrivalsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest struct {
			Arrivals              []map[string]interface{} `json:"arrivals"`
			RealtimeDataUpdatedAt *int                     `json:"realtimeDataUpdatedAt,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	}

	return response, nil
}

// ParseGetStopsIdDeparturesResponse parses an HTTP response from a GetStopsIdDeparturesWithResponse call
func ParseGetStopsIdDeparturesResponse(rsp *http.Response) (*GetStopsIdDeparturesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStopsIdDeparturesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest struct {
			Departures            []map[string]interface{} `json:"departures"`
			RealtimeDataUpdatedAt *int                     `json:"realtimeDataUpdatedAt,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	}

	return response, nil
}

// ParseGetTripsResponse parses an HTTP response from a GetTripsWithResponse call
func ParseGetTripsResponse(rsp *http.Response) (*GetTripsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTripsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest struct {
			RealtimeDataUpdatedAt *int                     `json:"realtimeDataUpdatedAt,omitempty"`
			Trips                 []map[string]interface{} `json:"trips"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	}

	return response, nil
}

// ParseGetTripsIdResponse parses an HTTP response from a GetTripsIdWithResponse call
func ParseGetTripsIdResponse(rsp *http.Response) (*GetTripsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTripsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest struct {
			RealtimeDataUpdatedAt *int                   `json:"realtimeDataUpdatedAt,omitempty"`
			Trip                  map[string]interface{} `json:"trip"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	}

	return response, nil
}
